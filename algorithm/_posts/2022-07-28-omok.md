---
layout: post
title: "[백준 - 2615] 오목"
description: >
  백준 Silver2
sitemap: false
tags: [Brute Force]
hide_last_modified: true
---

# 5️⃣ 오목

# 📖 가져다 쓰기

브루트 포스를 사용하는 문제였다. 이 문제를 브루트 포스로 풀어도 되는 이유는 다음과 같다.

+ 바둑판의 데이터 입력수는 19x19 = 361 

<img width="691" alt="스크린샷 2022-07-26 오전 9 50 42" src="https://user-images.githubusercontent.com/88064555/181409273-41b4573a-fa3a-476a-aa6a-84476207fd03.png">

이 문제는 N ≦ 500에 해당하므로 O(n^3)의 시간복잡도로 해결할 수 있고 브루트 포스는 이를 만족하기 때문에 나는 모든 위치를 탐색해보며 오목인지 아닌지를 판별하기로 결정하였다.

# 📐 과정 설계/관리

## 1트

![연습장-50](https://user-images.githubusercontent.com/88064555/181412325-9f24d6b3-0ebb-47c1-ac5c-6fda31e80a7e.jpg)

상하좌우, 대각선 8방향을 탐색하며 같은 색의 돌을 만날 경우 count를 증가시켜주며 5를 만족할 때만 승리 판정을 짓는다.

하지만 이 경우에는 형광펜과 같이 꺾인 오목의 반례가 생긴다.


## 2트

![연습장-51](https://user-images.githubusercontent.com/88064555/181412407-4e347b7b-e962-425c-ad30-2c879e283b0c.jpg)

(1,1)부터 (N,N)까지 모든 위치를 탐색해보며 돌을 만났을 때 행,열,대각 3 부분을 검사하여 같은 색의 돌을 세준다.

그렇게 하여 count가 5인 것만 추린다. 이 경우 역시 어이없는 실수였는데 오목은 돌이 **연속적으로** 5개가 놓여야 하는데 이러한 설계는 **불연속적인** 5개도 포함시키므로 틀린다.

## 3트

![연습장-52](https://user-images.githubusercontent.com/88064555/181412452-6ebde041-93ec-4edc-b296-8c98dfb3749e.jpg)

내가 이 문제에서 간과했던 부분은 오목의 **좌선상선**을 출력해야 한다는 점이다.

따라서 8방향 탐색이 아닌 ↗️ ➡️ ↘️ ⬇️ 의 4방향만 탐색해야 **좌선상선** 조건을 만족시킬 수 있다.

나는 코드 구현을 할 때 while 문 중간에 count=5가 되었을 때 탈출하는 방식이 아닌 while 문이 다 끝나고 최종적인 count를 보아서 5일 때만 승리 판정을 짓도록 했다. 그래서 따로 육목검사는 안해도 된다고 생각하였는데 반례가 있었다.


![연습장-56](https://user-images.githubusercontent.com/88064555/181412504-4821f89d-1ce5-4f3c-8f0e-70aabece7ec4.jpg)


최종적으로 오목의 시작 이전 돌을 검사해보는 코드를 추가하여 통과하였다.

# 👨🏻‍💻 CODE

```python
import sys
input = sys.stdin.readline

omok = []

for i in range(19):
    omok.append(list(map(int,input().split())))

dx = [-1,0,1,1]
dy = [1,1,1,0]

for i in range(19):
    for j in range(19):
        color = omok[i][j]
        if color != 0:
            for k in range(4):
                nx = i + dx[k]
                ny = j + dy[k]

                if 0<=nx<19 and 0<=ny<19 and omok[nx][ny] == color:
                    count = 2

                    a = dx[k]
                    b = dy[k]

                    while 0<=nx+a<19 and 0<=ny+b<19 and omok[nx+a][ny+b] == color:
                        count += 1
                        a += dx[k]
                        b += dy[k]
                    
                    # if (i,j) == (4,1):
                    #     print("카운트: {0}, 방향: {1},{2}".format(count, dx[k],dy[k]))
                    if count == 5:
                        # 육목 체크
                        if (i-dx[k] < 0 or j-dy[k] < 0) or omok[i-dx[k]][j-dy[k]] != color:
                            print(color)
                            print(i+1,j+1)
                            sys.exit(0)
                        
print(0)
```
